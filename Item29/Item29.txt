class PrettyMenu 
{
public:
	void changeBackground(std::istream& imgSrc); // change background image
private:
	Mutex mutex; // mutex for this object
	Image *bgImage; // current background image
	int imageChanges; // # of times image has been changed
};


void PrettyMenu::changeBackground(std::istream& imgSrc)
{
	lock(&mutex); // acquire mutex (as in Item 14)
	delete bgImage; // get rid of old background
	++imageChanges; // update image change count
	bgImage = new Image(imgSrc); // install new background
	unlock(&mutex); // release mutex
}


The above fails exception safety:
1.Leak no resources : if new Image(imgSrc) yields an exception, mutex is held forever.
2.Don't allow data structures to become corupted : If new throws exception, bgImage is left pointing to deleted memory.

Problem1 can be solved by using RAII. 
	Lock ml(&mutex);
	
Exception safe functions offer 3 gaurantee:
1.Basic Gaurantee : the program remains in a valid state i.e. no object/data structure is corrupted. To acheive our problem2, we can make bgImage continue to have old/default background image. But client will not be able to predict which.
2.Strong Gaurantee : Calls to such functions remains atomic i.e. if they succeed they succeed completely else the program state is as if they have never been called.
3.No throw gaurantee : promise never to throw exceptions, because they always do what they promise to do. All operations on built-in types (e.g., ints, pointers, etc.) are nothrow (i.e., offer the nothrow guarantee).   Anything using dynamically allocated
memory (e.g., all STL containers) typically throws a bad_alloc exception if it can’t find enough memory to satisfy a request. So we cannot apply no throw there.

Exception-safe code must offer one of the three guarantees above. If it doesn’t, it’s not exception-safe. The choice, then, is to determine which guarantee to offer for each of the functions you write.
	
Better to provide strong gaurantee in changeBackground. It can be achieved by 

class PrettyMenu {
	std::tr1::shared_ptr<Image> bgImage;
};
void PrettyMenu::changeBackground(std::istream& imgSrc)
{
	Lock ml(&mutex);
	bgImage.reset(new Image(imgSrc)); // replace bgImage’s internal pointer with the result of the “new Image” expression
	++imageChanges;
}

There are 2 changes done : 1. Make bgImange shared_ptr usage of RAII is very good and we don't have to delete bgImage now.
2.Rearrange the ++imageChanges, the imageChanges will be incremented only if the reset is successfull



